#include <VGAGraphics.h>
#include <SPI.h>
#include "nRF24L01.h"
#include "RF24.h"
//#include "printf.h"
#define S_BEGIN 5

// Enums
typedef enum State {
  NO_LINE,
  ON_LINE,
  PASSED_LINE,
} state_t;

typedef enum StateDir {
  NEGX = 0,
  NEGY = 1,
  POSX = 2,
  POSY = 3
} state_dir_t;

typedef enum Boundary {
  LOW_TREASURE = 5,
  MID_TREASURE = 4,
  HIGH_TREASURE = 3,
  WALL = 2,
  NOTHING = 1,
  UNKNOWN = 0
} boundary_t;

#define  BLACK   0x0000
#define BLUE    0x001F
#define RED     0xF800
#define GREEN   0x07E0
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define WHITE   0xFFFF

#define DIMX 5
#define DIMY 4
#define LWIDTH 4

#define MASK_POSY 0x1
#define MASK_POSX 0x2
#define MASK_NEGY 0x4
#define MASK_NEGX 0x8

typedef struct DataString {
  unsigned char x, y, next_dir, negX_bound, posX_bound, negY_bound, posY_bound;
  bool treasure7, treasure12, treasure17;
  bool done;
} data_string_t;


PROGMEM const char kir[] =
{
  0x48,0x48,0x4c,0x95,0x90,0x4c,0x4c,0x4c,0x6c,0x90,0x91,0x70,0x70,0x70,0x70,0x70,0x48,0x24,0x24,0x24,0x48,0x48,0x6c,0x48,0x48,0x6c,0xb1,0x91,0x71,0x91
,0x4c,0x4c,0x6c,0x95,0x91,0x4c,0x4c,0x4c,0x95,0xb5,0xb5,0x90,0x94,0x94,0x95,0x90,0x6c,0x24,0x24,0x44,0x48,0x48,0x48,0x48,0x24,0x6c,0x91,0x90,0x6c,0x91
,0x4c,0x70,0x94,0xb5,0xb5,0x95,0x6c,0x6c,0xb5,0xb5,0xb5,0xb5,0x94,0x90,0x90,0x91,0x48,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x48,0x4c,0x70,0x70,0x70,0x91
,0x4c,0x70,0x70,0xb5,0xb5,0xb9,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0x94,0x90,0xb1,0x91,0x6c,0x44,0x24,0x24,0x24,0x24,0x28,0x48,0x6c,0x6c,0x6c,0x6c,0x90,0xb1
,0x4c,0x4c,0x70,0x94,0x94,0xb5,0x94,0xb5,0xd5,0xb5,0xb5,0xb5,0x91,0x91,0x8d,0x91,0x91,0x8d,0x68,0x44,0x24,0x48,0x4c,0x4c,0x6c,0x6c,0x70,0x70,0x90,0x91
,0x48,0x28,0x4c,0x70,0x70,0x70,0xb5,0xd5,0xb5,0xb5,0xb5,0x91,0x91,0xb1,0xb6,0xb2,0xb1,0xb2,0x8d,0x68,0x6c,0x70,0x4c,0x48,0x4c,0x6c,0x90,0x91,0x91,0xb1
,0x4c,0x48,0x28,0x4c,0x6c,0x70,0x90,0x91,0xb5,0xb5,0x91,0x8d,0xb1,0xd2,0xd2,0xd2,0xb2,0xd6,0x8d,0x48,0x6c,0x70,0x4c,0x48,0x48,0x6c,0x6c,0x91,0x91,0x91
,0x48,0x4c,0x48,0x4c,0x4c,0x70,0x70,0x6c,0x6c,0x6c,0x68,0xad,0xd1,0xf6,0xfa,0xfb,0xf6,0xb1,0x8d,0x48,0x48,0x4c,0x48,0x48,0x48,0x48,0x8c,0x91,0x91,0x6c
,0x28,0x6c,0x70,0x90,0x90,0x91,0x90,0x6c,0x4c,0x68,0x8c,0xd1,0xfa,0xfa,0xfb,0xfa,0xf6,0xd1,0x8d,0x48,0x44,0x48,0x28,0x24,0x44,0x68,0x90,0x91,0x91,0x91
,0x4c,0x70,0x90,0x94,0x94,0x91,0x6c,0x6c,0x68,0x68,0xb1,0xf6,0xf6,0xfa,0xfa,0xf6,0xd6,0xd1,0x8d,0x68,0x48,0x48,0x48,0x24,0x44,0x48,0x6c,0x91,0x91,0x95
,0x70,0x70,0x90,0x90,0x70,0x6c,0x6c,0x48,0x68,0x68,0xd1,0xf6,0xf6,0xfa,0xfa,0xf6,0xd6,0xd1,0xad,0x68,0x44,0x48,0x48,0x48,0x48,0x6c,0x71,0x91,0x95,0xb5
,0x90,0x90,0x70,0x4c,0x4c,0x4c,0x6c,0x6c,0x8d,0x8c,0xf6,0xfa,0xfa,0xfa,0xfa,0xf6,0xd6,0xd1,0xad,0x68,0x44,0x48,0x48,0x48,0x48,0x4c,0x70,0x90,0x90,0x95
,0x94,0x90,0x6c,0x48,0x28,0x4c,0x4c,0x8d,0xad,0xb1,0xd6,0xd2,0xd1,0xf6,0xd6,0xd2,0xd6,0xd6,0xb1,0x68,0x44,0x68,0x48,0x24,0x48,0x70,0x95,0x91,0x90,0x95
,0xb5,0xb4,0x90,0x4c,0x4c,0x4c,0x4c,0x91,0xd1,0xd6,0xb1,0x8d,0xad,0xf6,0xb1,0xad,0x8d,0xb1,0xad,0x68,0x44,0x8d,0x48,0x28,0x48,0x91,0x95,0x91,0x90,0x70
,0xb5,0xb5,0x91,0x4c,0x4c,0x4c,0x4c,0x91,0xd1,0xf6,0xfa,0xd6,0xd6,0xf6,0xd1,0xd2,0xb1,0x8d,0xb1,0x8d,0x68,0x8d,0x48,0x28,0x48,0x6c,0x6c,0x6c,0x6c,0x6c
,0x95,0x95,0x70,0x4c,0x4c,0x4c,0x4c,0x6c,0xb1,0xf6,0xfa,0xfa,0xf6,0xf6,0xd1,0xf6,0xfa,0xf6,0xd1,0x89,0x8d,0x8c,0x48,0x28,0x48,0x71,0x91,0x90,0x90,0x90
,0x91,0x6c,0x4c,0x71,0x91,0x91,0x6c,0x6c,0x6c,0xf6,0xf6,0xf6,0xf6,0xd6,0xd1,0xf6,0xf6,0xd2,0xad,0x68,0xd1,0x68,0x24,0x24,0x48,0x6c,0x90,0x94,0xb5,0x94
,0x70,0x4c,0x4c,0x6c,0x95,0xb5,0xb5,0x90,0x90,0xd1,0xd1,0xd6,0xd1,0xad,0xb1,0xd6,0xd6,0xd1,0x8d,0x69,0x8d,0x6c,0x24,0x24,0x48,0x6c,0x90,0xb5,0xb5,0xb5
,0x70,0x4c,0x4c,0x4c,0x91,0xb5,0xb5,0xb5,0xb1,0xd5,0xd6,0xad,0xd2,0xd1,0xb1,0xb1,0xd1,0xad,0x68,0x44,0x44,0x48,0x44,0x24,0x48,0x4c,0x6c,0x6c,0x91,0xb5
,0x90,0x6c,0x4c,0x4c,0x70,0x91,0xb5,0xb5,0x91,0xb1,0xf6,0xf6,0xd2,0xd2,0xad,0xd1,0xd1,0x8d,0x68,0x44,0x24,0x24,0x24,0x24,0x48,0x6c,0x6c,0x6c,0x6c,0x90
,0x95,0x95,0x71,0x4c,0x70,0x91,0x91,0x91,0x70,0x91,0xd6,0xf6,0xd6,0xd2,0xd1,0xd2,0xb1,0x89,0x68,0x48,0x24,0x24,0x24,0x24,0x68,0xb5,0xd5,0xd5,0xb5,0x90
,0xb5,0x95,0x6c,0x4c,0x71,0x71,0x70,0x70,0x70,0x6c,0xb1,0xf6,0xf6,0xf6,0xd1,0xad,0x8d,0x68,0x6d,0x68,0x24,0x24,0x24,0x44,0x6c,0xb4,0xd5,0xd5,0xb5,0xb5
,0x94,0x70,0x4c,0x4c,0x70,0x70,0x6c,0x91,0x70,0x71,0xb1,0xb1,0xb1,0xad,0x89,0x68,0x89,0x8d,0x44,0x48,0x44,0x44,0x44,0x44,0x68,0x90,0x95,0xb5,0xb5,0x95
,0x94,0x70,0x4c,0x4c,0x70,0x70,0x70,0x91,0x6c,0xb1,0xad,0xb1,0xb1,0xad,0x8d,0xb1,0xb1,0xad,0x48,0x44,0x68,0x68,0x68,0x48,0x48,0x6c,0x91,0x90,0x70,0x70
,0x70,0x4c,0x4c,0x4c,0x70,0x91,0x71,0xb5,0xb1,0x8d,0x68,0xd1,0xd1,0xb1,0xb1,0xd1,0xd1,0xad,0x44,0x24,0x49,0x8d,0x8d,0x68,0x48,0x6c,0x91,0x91,0x91,0x91
,0x4c,0x4c,0x4c,0x4c,0x6c,0x6d,0x6d,0x6d,0x8d,0x24,0x8d,0xd1,0xd1,0xd1,0xd1,0xd2,0xb1,0x6d,0x24,0x24,0x25,0x69,0xb1,0x8d,0x68,0x8d,0xb1,0xb1,0xb1,0xb5
,0x4c,0x4c,0x4c,0x6d,0x49,0x49,0x49,0x24,0x24,0x44,0xd1,0xd1,0xd1,0xd1,0xd6,0xd1,0xb1,0x44,0x24,0x24,0x24,0x45,0x49,0x6d,0x8d,0xb1,0xb1,0xb1,0xb1,0xb5
,0x4c,0x49,0x49,0x49,0x29,0x49,0x24,0x25,0x25,0x89,0xd6,0xd6,0xd6,0xd6,0xd6,0xd1,0x8d,0x24,0x24,0x25,0x25,0x49,0x49,0x49,0x49,0x8d,0xb1,0x91,0x91,0xb5
,0x4c,0x29,0x25,0x25,0x25,0x24,0x24,0x25,0x49,0xd6,0xf6,0xf6,0xf6,0xf6,0xf6,0xd2,0x44,0x24,0x25,0x25,0x49,0x25,0x25,0x49,0x49,0x49,0x49,0x91,0xb1,0xb1
,0x4c,0x29,0x25,0x25,0x24,0x24,0x25,0x25,0x8d,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0x8d,0x24,0x25,0x25,0x25,0x49,0x24,0x25,0x29,0x25,0x24,0x24,0x24,0x91,0xb1
};


VGAGraphics lcd;
int bwidth;
int llengthx;
int llengthy;
int y_off;

// we use entire length of X
// 240x240

RF24 radio(9,10);

// Radio pipe addresses for the 2 nodes to communicate.
const uint64_t pipes[2] = { 0x0000000010LL, 0x0000000011LL };

// The various roles supported by this sketch
typedef enum { role_ping_out = 1, role_pong_back } role_e;

// The debug-friendly names of those roles
const char* role_friendly_name[] = { "invalid", "Ping out", "Pong back"};

// The role of the current running sketch
role_e role = role_pong_back;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  lcd.init();
  lcd.clear();

  pinMode(S_BEGIN, OUTPUT);
  digitalWrite(S_BEGIN, LOW);
  

  bwidth = (lcd.width()-DIMX*LWIDTH)/DIMX; //box width
  llengthx = (bwidth+LWIDTH)*DIMX; //grid line length in X
  llengthy = (bwidth+LWIDTH)*DIMY; //grid line length in Y
  y_off = (lcd.height()-llengthy)/2;

  // draw vertical bars
  int idx = bwidth/2;
  for (int i=0; i < DIMX; i++) {
    lcd.fillRect(idx, y_off, LWIDTH, llengthy, CYAN); //widht, height
    idx += LWIDTH+bwidth;
  }

  // draw horz
  int idy = bwidth/2;
   for (int i=0; i < DIMY; i++) {
    lcd.fillRect(0, y_off+idy, llengthx, LWIDTH, CYAN);
    idy += LWIDTH+bwidth;
  }
  

  // y boundary
  lcd.fillRect(0, y_off, llengthx, LWIDTH, RED);
  lcd.fillRect(0, y_off + llengthy-LWIDTH, llengthx, LWIDTH, RED);

  //x boundary
  lcd.fillRect(0, y_off, LWIDTH, llengthy, RED);
  lcd.fillRect(llengthx-LWIDTH, y_off, LWIDTH, llengthy, RED);


  lcd.setCursor(2,3);
  lcd.setTextColor(GREEN);
  lcd.setTextSize(2);
  lcd.print("Team 5 is the best!");
  //lcd.drawRGB8Bitmap(50, 50, kir, 30, 30);
  lcd.setCursor(0,0);

  //addWall(2,2, MASK_NEGX | MASK_POSX | MASK_POSY | MASK_NEGY, 7); //should draw at 2, 1

  ///////// RADIO////////
  // Print preamble

  //Serial.begin(57600);
  //Serial.print_begin();
  Serial.print("\n\rRF24/examples/GettingStarted/\n\r");
  Serial.print("ROLE: %s\n\r");
  Serial.print(role_friendly_name[role]);
  Serial.print("*** PRESS 'T' to begin transmitting to the other node\n\r");

  // Setup and configure rf radio
  radio.begin();
  // optionally, increase the delay between retries & # of retries
  radio.setRetries(15,15);
  //radio.setAutoAck(true);
  // set the channel
  radio.setChannel(0x50);
  // set the power
  // RF24_PA_MIN=-18dBm, RF24_PA_LOW=-12dBm, RF24_PA_MED=-6dBM, and RF24_PA_HIGH=0dBm.
  radio.setPALevel(RF24_PA_HIGH);
  //RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps
  radio.setDataRate(RF24_250KBPS);

  radio.setPayloadSize(sizeof(data_string_t));

  radio.openWritingPipe(pipes[1]);
  radio.openReadingPipe(1,pipes[0]);

  radio.startListening();

  radio.printDetails();
  delay(100);
}

void loop() {
if( 1) {
    // if there is data ready
    if ( radio.available() ) {
      // Dump the payloads until we've gotten everything

      data_string_t data;

      // Fetch the payload, and see if this was the last one.
      if(radio.read( &data, sizeof(data) )) {
        
        // Print the received data as a decimal
        Serial.print("Got payload %d... suck it trebek \n");
    

        // Delay just a little bit to let the other unit
        // make the transition to receiver
        delay(20);
     
        // First, stop listening so we can talk
        //radio.stopListening();
        uint8_t walls = 0;
        // POsx is right horz
        walls |= data.posX_bound == WALL ? MASK_NEGY : 0;
        walls |= data.negX_bound == WALL ? MASK_POSY : 0;
        walls |= data.posY_bound == WALL ? MASK_POSX : 0;
        walls |= data.negY_bound == WALL ? MASK_NEGX : 0;
        

        uint8_t treas = 0;
        if (data.treasure17)
          treas = 17;
        else if (data.treasure12)
          treas = 12;
        else if (data.treasure7)
          treas = 7;
          
        addWall(data.y, (DIMY-1) - data.x, walls, treas);
         

        if (data.done) {
          digitalWrite(S_BEGIN, HIGH);

              lcd.setCursor(15,100);
            lcd.setTextColor(MAGENTA);
            lcd.setTextSize(7);
            lcd.print("DONE!");
        }
     }

    }
  }

  delay(100);

}


// not 
void addWall(uint8_t x, uint8_t y, uint8_t walls, uint8_t tfreq)
{
  uint8_t hbw = bwidth/2;
  uint8_t lw2 = LWIDTH/2;
  // centered top left of intersection
  uint8_t xcent = x*(bwidth + LWIDTH) + hbw;
  uint8_t ycent = y*(bwidth + LWIDTH) + y_off + hbw;

  if (walls & MASK_POSX) {
    lcd.fillRect(xcent + hbw, ycent-hbw, LWIDTH, bwidth+LWIDTH, RED);  
  }

  if (walls & MASK_NEGX) {
    lcd.fillRect(xcent - hbw, ycent-hbw, LWIDTH, bwidth+LWIDTH, RED);  
  }

  if (walls & MASK_NEGY) {
     lcd.fillRect(xcent - hbw, ycent -hbw, bwidth+LWIDTH, LWIDTH, RED);  
  }

  if (walls & MASK_POSY) {
     lcd.fillRect(xcent - hbw, ycent + hbw, bwidth+LWIDTH, LWIDTH, RED);  
  }

  lcd.fillCircle(xcent+lw2, ycent+lw2, 5, GREEN);

  if (tfreq) {
    //char s[] = (tfreq == 17) ? "17" : (tfreq == 12) ? "12" : " 7";
    uint8_t rad = 10;
    lcd.fillCircle(xcent+lw2, ycent+lw2, rad, YELLOW);
    
    lcd.setCursor(xcent+lw2-rad/2,ycent+lw2-rad/2);
    lcd.setTextSize(2);
    uint16_t color;
    if (tfreq == 17) {
      color = BLUE;
    } else if (tfreq == 12) {
      color = GREEN;
    } else {
      color = RED;
    }
    lcd.setTextColor(color);

    if (tfreq == 17) {
      color = BLUE;
      lcd.print("17");
    } else if (tfreq == 12) {
      color = GREEN;
      lcd.print("12");
    } else {
      color = RED;
      lcd.print("7");
    }
  }
}
    

